use anchor_client::anchor_lang::accounts::program;
use anchor_client::anchor_lang::system_program::ID as SYSTEM_PROGRAM_ID;
use anchor_client::anchor_lang::Key;
use anchor_client::solana_client::{
    nonblocking::rpc_client::RpcClient, rpc_config::RpcRequestAirdropConfig,
};
use anchor_client::solana_sdk::{
    commitment_config::{CommitmentConfig, CommitmentLevel},
    pubkey::Pubkey,
};
use anchor_client::Program;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anchor_client::{
    solana_sdk::{signature::Keypair, signer::Signer, system_program},
    Client, Cluster,
};
use groth_16_verifier::client::receipt_to_proof;
use groth_16_verifier::Proof;
use methods::{HELLO_GUEST_ELF, HELLO_GUEST_ID};
use risc0_zkvm::{default_prover, sha::Digestible, ExecutorEnv, ProverOpts};
use solana_program::pubkey;
use std::borrow::Borrow;
use std::fs::File;
use std::io::{self, Write};
use std::sync::Arc;
use tokio::time::Sleep;
use tracing::instrument::WithSubscriber;
use tracing::{debug, error, info, trace};

use clap::Parser;
use solana_examples::{accounts, instruction, ProgramData};

// Provide CLI so that we can use the same program to setup our program as well
// as increment our nonce
#[derive(Parser, Debug)]
#[command(version)]
struct Args {
    /// Initilize the Example Solana Program instead of incrementing the nonce
    #[arg(short, long, default_value_t = false)]
    init: bool,
}

type PROGRAM = Program<Arc<Keypair>>;

const SELECTOR: u32 = 1; // Going to assume only one verifier in our test

// Used to convert our image_id from a [u32; 8] into a [u8; 32] as expected of our groth verifier
fn convert_array(input: [u32; 8]) -> [u8; 32] {
    let bytes: Vec<u8> = input.iter().flat_map(|&x| x.to_le_bytes()).collect();
    bytes.try_into().unwrap()
}

async fn init(user: Arc<Keypair>, example_program: PROGRAM, program_data_address: Pubkey) {
    info!("Attempting to initilize program data");

    let rpc = example_program.async_rpc();

    let slot = rpc.get_slot().await.unwrap();

    example_program
        .request()
        .accounts(accounts::Initialize {
            authority: user.pubkey(),
            program_data: program_data_address,
            system_program: SYSTEM_PROGRAM_ID,
        })
        .args(instruction::Initialize {
            image_id: convert_array(HELLO_GUEST_ID),
            selector: SELECTOR,
        })
        .payer(user.clone())
        .signer(&user)
        .send()
        .await
        .expect("Was unable to submit the initilization transaction");

    info!("Transaction Successful, our program is now ready for verifying proofs");
}

async fn increment_nonce(example_program: PROGRAM, program_data_address: Pubkey) {
    info!("Attempting to increment program nonce");

    let program_data: ProgramData = example_program
        .account(program_data_address)
        .await
        .expect("Was unable to find program data account for example");

    let nonce: u32 = program_data.nonce;

    info!("Current Nonce value is ${nonce}");

    // Increment the current nonce for our transaction to be accepted
    let input: u32 = nonce + 1;

    info!("Constructing proof to increment nonce value to {input}");
    let prover = default_prover();

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prover_options = ProverOpts::groth16();
    let prove_info = prover
        .prove_with_opts(env, HELLO_GUEST_ELF, &prover_options)
        .unwrap();

    let receipt = prove_info.receipt;

    info!("Groth 16 proof for nonce increment transaction successfuly created, submitting transaction to the program.");

    let groth16_receipt = receipt
        .inner
        .groth16()
        .expect("Unable to get Groth 16 proof from main receipt");

    let proof =
        receipt_to_proof(groth16_receipt).expect("Unable to generate proof from Groth Receipt");

    let (router_pda_address, _) = Pubkey::find_program_address(&[b"router"], &verifier_router::ID);
    debug!("Using the address: {router_pda_address} as the Router Account");

    // Get the verifier entry account address
    let (verifier_entry_address, _) = Pubkey::find_program_address(
        &[b"verifier", &SELECTOR.to_le_bytes()],
        &verifier_router::ID,
    );

    debug!("Using the address: {verifier_entry_address} as the Verifier Entry Account");

    example_program
        .request()
        .accounts(accounts::IncrementNonce {
            program_data: program_data_address,
            router: verifier_router::ID,
            router_account: router_pda_address,
            verifier_entry: verifier_entry_address,
            system_program: SYSTEM_PROGRAM_ID,
            verifier_program: groth_16_verifier::ID,
        })
        .args(instruction::IncrementNonce {
            journal_nonce: input,
            proof: proof,
        })
        .send()
        .await
        .expect("Unable to send increment nonce transaction");

    info!("Transaction succesfull, nonce incremented");
}

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args = Args::parse();
    info!("Example Risc0 Solana Program has started!");

    // Construct a new user and request solana for the transaction
    let user = Arc::new(Keypair::new());
    let user_address = user.pubkey();
    debug!("Generated a keypair for this transaction: {user:?}");
    let client = Client::new(Cluster::Localnet, user.clone());

    debug!("Airdrop was completed for address: {user_address}");

    let solana_example_address = solana_examples::ID;
    debug!("Interacting with solana example program at address: {solana_example_address}");

    let example_program = client
        .program(solana_examples::ID)
        .expect("Was unable to construct a client for the solana program on localnet.");

    let (program_data_address, _) = Pubkey::find_program_address(&[b"data"], &solana_examples::ID);

    debug!("Account Program Data PDA Address is: {program_data_address}");

    let rpc = example_program.async_rpc();

    let latest_blockhash = rpc
        .get_latest_blockhash()
        .await
        .expect("Could not get latest blockhash");

    rpc.request_airdrop_with_config(
        &user_address,
        5000000000,
        RpcRequestAirdropConfig {
            recent_blockhash: Some(latest_blockhash.to_string()),
            commitment: Some(CommitmentConfig {
                commitment: CommitmentLevel::Finalized,
            }),
        },
    )
    .await
    .expect("Was unable to request airdrop on localnet testnet.");

    info!("Going to loop until we have received balance from airdrop!");

    loop {
        let balance_result = rpc.get_balance(&user_address).await;
        if let Ok(balance) = balance_result {
            trace!("Balance is: {balance}");
            if balance > 0 {
                break;
            } else {
                debug!("Was unable to fetch balance for user account");
            }
        }
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
    }

    if args.init {
        init(user, example_program, program_data_address).await
    } else {
        increment_nonce(example_program, program_data_address).await
    }
}
